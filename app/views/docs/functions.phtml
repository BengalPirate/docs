<?php

use Appwrite\Utopia\View;

$events = $this->getParam('events', []);
$runtimes = $this->getParam('runtimes', []);

?>

<p>
    Appwrite Functions let you extend Appwrite by adding your own code and logic. 
    You can think of them as code snippets that are triggered by server events, webhooks, scheduled executions, or user invokation.
    Each function will have their own URL, execute in their own isolated container, and have their own configurable environment variables and permissions.
    With these features, Appwrite Functions unlock limitless potential to expand Appwrite's capabilities with custom logic and integrations.
</p>

<h2><a href="#gettingStarted" id="gettingStarted">Getting Started</a></h2>
<p>
    Appwrite Functions unlock limitless possibilities, but it's simple to get started. You can deploy your first function and execute it in minutes.
</p>

<ul class="phases clear" data-ui-phases>
    <li>
        <h3>Node.js</h3>
        <div>
        <div class="ide margin-top-small" data-lang="javascript" data-lang-label="JavaScript">
            <pre class="line-numbers"><code class="prism language-js" data-prism>export default async ({ res }) => {
    return res.json({
        motto: 'Build Fast. Scale Big. All in One Place.'
    });
};</code></pre>
        </div>
        </div>
    </li>
    <li>
        <h3>PHP</h3>
        <div>
        <div class="ide margin-top-small" data-lang="php" data-lang-label="PHP">
            <pre class="line-numbers"><code class="prism language-php" data-prism>return function ($context) {
    return $context->res->json([
        'motto' => 'Build Fast. Scale Big. All in One Place.'
    ]);
}</code></pre>
        </div>
        </div>
    </li>
    <li>
        <h3>Python</h3>
        <div>
        <div class="ide margin-top-small" data-lang="python" data-lang-label="Python">
            <pre class="line-numbers"><code class="prism language-python" data-prism>def main(context):
    return context.res.json({
        "motto": "Build Fast. Scale Big. All in One Place.",
})</code></pre>
        </div>
        </div>
    </li>
    <li>
        <h3>Ruby</h3>
        <div>
        <div class="ide margin-top-small" data-lang="ruby" data-lang-label="Ruby">
            <pre class="line-numbers"><code class="prism language-ruby" data-prism>def main(context)
    return context.res.json(
        {
            "motto": "Build Fast. Scale Big. All in One Place."
        }
    )
end</code></pre>
        </div>
        </div>
    </li>
    <li>
        <h3>Deno</h3>
        <div>
        <div class="ide margin-top-small" data-lang="typescript" data-lang-label="Deno">
            <pre class="line-numbers"><code class="prism language-typescript" data-prism>export default ({ req, res, log, error }: any) => {
  return res.json({
    motto: "Build Fast. Scale Big. All in One Place."
  });
};</code></pre>
        </div>
        </div>
    </li>
    <li>
        <h3>Dart</h3>
        <div>
        <div class="ide margin-top-small" data-lang="dart" data-lang-label="Dart">
            <pre class="line-numbers"><code class="prism language-dart" data-prism>import 'dart:async';

Future<dynamic> main(final context) async {
    return context.res.json({
        'motto': 'Build Fast. Scale Big. All in One Place.',
    });
}</code></pre>
        </div>
        </div>
    </li>
    <li>
        <h3>Swift</h3>
        <div>
        <div class="ide margin-top-small" data-lang="swift" data-lang-label="Swift">
            <pre class="line-numbers"><code class="prism language-swift" data-prism>import Foundation

            func main(context: RuntimeContext) async throws -> RuntimeOutput {
    return try context.res.json([
        "motto": "Build Fast. Scale Big. All in One Place."
    ])
}</code></pre>
        </div>
        </div>
    </li>
    <li>
        <h3>.NET</h3>
        <div>
        <div class="ide margin-top-small" data-lang="csharp" data-lang-label="C#">
            <pre class="line-numbers"><code class="prism language-csharp" data-prism>namespace DotNetRuntime;
public class Handler {
    public async Task<RuntimeOutput> Main(RuntimeContext Context) 
    {
        return Context.Res.Json(new Dictionary<string, object?>()
        {
            { "motto", "Build Fast. Scale Big. All in One Place." }
        });
    }
}</code></pre>
        </div>
        </div>
    </li>
    <li>
        <h3>Kotlin</h3>
        <div>
        <div class="ide margin-top-small" data-lang="kotlin" data-lang-label="Kotlin">
            <pre class="line-numbers"><code class="prism language-kotlin" data-prism>package io.openruntimes.kotlin.src

import io.openruntimes.kotlin.RuntimeContext
import io.openruntimes.kotlin.RuntimeOutput

class Main {
    fun main(context: RuntimeContext): RuntimeOutput {
        return context.res.json(mutableMapOf(
            "motto" to "Build Fast. Scale Big. All in One Place.",
            "learn" to "https://appwrite.io/docs",
            "connect" to "https://appwrite.io/discord",
            "getInspired" to "https://builtwith.appwrite.io"
        ))
    }
}</code></pre>
        </div>

        </div>
    </li>
    <li>
        <h3>Java</h3>
        <div>
        <div class="ide margin-top-small" data-lang="java" data-lang-label="Java">
            <pre class="line-numbers"><code class="prism language-java" data-prism>package io.openruntimes.java.src;

import io.openruntimes.java.RuntimeContext;
import io.openruntimes.java.RuntimeOutput;
import java.util.HashMap;

public class Main {
    public RuntimeOutput main(RuntimeContext context) throws Exception {
        Map<String, Object> json = new HashMap<>();
        json.put("motto", "Build Fast. Scale Big. All in One Place.");
        return context.getRes().json(json);
    }
}</code></pre>
        </div>
        </div>
    </li>
    <li>
        <h3>C++</h3>
        <div>
        <div class="ide margin-top-small" data-lang="cpp" data-lang-label="C++">
            <pre class="line-numbers"><code class="prism language-csharp" data-prism>#include "../RuntimeResponse.h"
#include "../RuntimeRequest.h"
#include "../RuntimeOutput.h"
#include "../RuntimeContext.h"

namespace runtime {
  class Handler {
    public:
      static RuntimeOutput main(RuntimeContext &context) {
        Json::Value response;
        response["motto"] = "Build Fast. Scale Big. All in One Place.";
        return context.res.json(response);
      }
  };
}</code></pre>
        </div>
        </div>
    </li>
</ul>


<h2><a href="#exploreFeatures" id="exploreFeatures">Explore Features</a></h2>
<p>
    Appwrite Functions help you start small and scale big. 
    Now you've created your first Appwrite Function, it's time to learn the different ways to develop, deploy, and execute your Appwrite Functions. 
    To fully harness the power of Appwrite Functions, explore the following features.
</p>

<h3><a href="#templates" id="templates">Templates</a></h3>
<p>
    If you need to integrate Appwrite with a third-party API or add a function for common utilities, 
    there might already be a function template made by the Appwrite community that fits your needs. 
    Function templates are Appwrite Functions repositories that you can clone and add to your Appwrite instance.
</p>

<p>
<a href="/docs/[TODO]"><i class="icon-angle-circled-right"></i>Learn more about using function templates</a>
</p>

<h3><a href="#develop" id="develop">Develop</a></h3>
<p>
Writing Appwrite Functions should feel familiar to writing controllers in an HTTP server.
In your function, you'll receive a request object, add transformations and logic, then return a response.
Almost anything can be executed as code in an Appwrite Function.
</p>
<p>
<a href="/docs/functions-develop"><i class="icon-angle-circled-right"></i>Learn more about developing functions</a>
</p>

<h3><a href="#deploy" id="deploy">Deploy</a></h3>
<p>
    Appwrite Functions are designed to be maintainable and fit into a familiar development workflow.
    You can deploy them from a GitHub repository branch or using the Appwrite CLI.
</p>
<p>
<a href="/docs/functions-deploy"><i class="icon-angle-circled-right"></i>Learn more about using deploying functions</a>
</p>

<h3><a href="#execute" id="execute">Execute</a></h3>
<p>
Appwrite Functions can be executed directly through a request to the API, or triggered by events, webhooks, or scheduled executions. 
This flexible execution models unlocks many potential usecases for Appwrite functions.
Explore using Appwrite Functions to execute a complex routine of logic, or execute background tasks on a schedule.
</p>
<p>
<a href="/docs/functions-execute"><i class="icon-angle-circled-right"></i>Learn more about using executing functions</a>
</p>

<h3><a href="#runtime" id="runtime">Runtime</a></h3>
<p>
Appwrite supports many open-source runtimes. Find your prefered language and start writing your functions.
</p>
<p>
<a href="/docs/[TODO]"><i class="icon-angle-circled-right"></i>Learn more about using runtimes</a>
</p>
<h3><a href="#debug" id="debug">Debug</a></h3>
<p>
Let's be honest, we spend more time debugging our code than writing our code. 
So it's important to be able to log, debug, and test your Appwrite Functions in development and production.
</p>
<p>
<a href="/docs/[TODO]"><i class="icon-angle-circled-right"></i>Learn more about debugging functions</a>
</p>

<h2><a href="#upgrade" id="upgrade">Upgrade</a></h2>
<p>
    Appwrite Functions received major upgrades in Appwrite version 1.4. 
    If you still have functions from previous versions, [TODO: @matej what is the consequence what should they do?]
</p>
