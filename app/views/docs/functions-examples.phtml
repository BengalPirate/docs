<p>
  Appwrite Functions is all about flexibility.
  Behind the simple workflow hides some useful recipes that can help you accomplish your goals faster.
  Take a look at the following.
</p>
[TODO: @matej @luke -> Let's have some simple recipes here for common actions]

<h2>Currency Conversion API</h2>

<h3>Getting Started</h3>

<p>
  In this recipe, we'll build a simple function for currency conversion.
  Let's start with a static converstion rate. We'll show you how to integrate an API later in this example.
</p>

<ul class="phases clear" data-ui-phases>
  <li>
    <h3>Node.js</h3>
    <div>
      <p>Create a new file, <code>index.js</code>.</p>
      <p>Add the following code to <code>index.js</code>.</p>
      <div class="ide margin-top-small" data-lang="javascript" data-lang-label="JavaScript">
        <pre class="line-numbers"><code class="prism language-js" data-prism>export default async function ({ res }) {
  return res.send('1.13');
};</code></pre>
      </div>
    </div>
  </li>
  <li>
    <h3>PHP</h3>
    <div>
      <p>Create a new file, <code>index.php</code>.</p>
      <p>Add the following code to <code>index.php</code>.</p>
      <div class="ide margin-top-small" data-lang="php" data-lang-label="PHP">
        <pre class="line-numbers"><code class="prism language-php" data-prism>&lt;?php
return function ($context) {
  return $context->res->send('1.13');
};</code></pre>
      </div>
    </div>
  </li>
  <li>
    <h3>Python</h3>
    <div>
      <p>Create a new file, <code>index.py</code>.</p>
      <p>Add the following code to <code>index.py</code>.</p>
      <div class="ide margin-top-small" data-lang="python" data-lang-label="Python">
        <pre class="line-numbers"><code class="prism language-python" data-prism>def main(context):
  return context.res.send('1.13')</code></pre>
      </div>
    </div>
  </li>
  <li>
    <h3>Dart</h3>
    <div>
      <p>Create a new file, <code>index.dart</code>.</p>
      <p>Add the following code to <code>index.dart</code>.</p>
      <div class="ide margin-top-small" data-lang="dart" data-lang-label="Dart">
        <pre class="line-numbers"><code class="prism language-dart" data-prism>import 'dart:async';

Future&lt;dynamic> main(final context) async {
  return context.res.send('1.13');
}</code></pre>
      </div>
    </div>
  </li>
  <li>
    <h3>Ruby</h3>
    <div>
      <p>Create a new file, <code>index.rb</code>.</p>
      <p>Add the following code to <code>index.rb</code>.</p>
      <div class="ide margin-top-small" data-lang="ruby" data-lang-label="Ruby">
        <pre class="line-numbers"><code class="prism language-ruby" data-prism>def main(context)
  return context.res.send('1.13')
end</code></pre>
      </div>
    </div>
  </li>
</ul>

<p>This code will return <code>1.13</code> when the function is called, because 1â‚¬ equals approximately 1.13$.</p>
<p>Now, create a function in the Appwrite console, adding your Git repository as the remote source and using the path file you created as the entry point.</p>
<p>Finally, execute the function and visit the URL (like <code>ghrfu9ewji.functions.appwrite.app</code>) to see the response.</p>

<h3>Adding the Business Logic</h3>

<p>Now, let's update the function to use the request payload.</p>
<p>You can use a query string to pass data to your function. For example, <code>ghrfu9ewji.functions.appwrite.app?amount=5</code> will pass <code>5</code> as the <code>amount</code> parameter.</p>

<ul class="phases clear" data-ui-phases>
  <li>
    <h3>Node.js</h3>
    <div>
      <p>Update <code>index.js</code> to use <code>req.query.amount</code> to access the <code>amount</code> parameter, and return the conversion result.</p>
      <div class="ide margin-top-small" data-lang="javascript" data-lang-label="JavaScript">
        <pre class="line-numbers"><code class="prism language-js" data-prism>export default async function ({ req, res }) {
  const amountInEuros = Number(req.query.amount);
  const amountInDollars = amountInEuros * 1.13;
  return res.send(amountInDollars.toString());
};</code></pre>
      </div>
    </div>
  </li>
  <li>
    <h3>PHP</h3>
    <div>
      <p>Update <code>index.php</code> to use <code>$context->req->query['amount']</code> to access the <code>amount</code> parameter, and return the conversion result.</p>
      <div class="ide margin-top-small" data-lang="php" data-lang-label="PHP">
        <pre class="line-numbers"><code class="prism language-php" data-prism>&lt;?php
return function ($context) {
  $amountInEuros = $context->req->query['amount'];
  $amountInDollars = $amountInEuros * 1.13;
  return $context->res->send($amountInDollars);
};</code></pre>
      </div>
    </div>
  </li>
  <li>
    <h3>Python</h3>
    <div>
      <p>Update <code>index.py</code> to use <code>context.req.query['amount']</code> to access the <code>amount</code> parameter, and return the conversion result.</p>
      <div class="ide margin-top-small" data-lang="python" data-lang-label="Python">
        <pre class="line-numbers"><code class="prism language-python" data-prism>def main(context):
  amountInEuros = context.req.query['amount']
  amountInDollars = amountInEuros * 1.13
  return context.res.send(amountInDollars)</code></pre>
      </div>
    </div>
  </li>
  <li>
    <h3>Dart</h3>
    <div>
      <p>Update <code>index.dart</code> to use <code>context.req.query['amount']</code> to access the <code>amount</code> parameter, and return the conversion result.</p>
      <div class="ide margin-top-small" data-lang="dart" data-lang-label="Dart">
        <pre class="line-numbers"><code class="prism language-dart" data-prism>import 'dart:async';

Future&lt;dynamic> main(final context) async {
  final amountInEuros = context.req.query['amount'];
  final amountInDollars = amountInEuros * 1.13;
  return context.res.send(amountInDollars);
}</code></pre>
      </div>
    </div>
  </li>
  <li>
    <h3>Ruby</h3>
    <div>
      <p>Update <code>index.rb</code> to use <code>context.req.query['amount']</code> to access the <code>amount</code> parameter, and return the conversion result.</p>
      <div class="ide margin-top-small" data-lang="ruby" data-lang-label="Ruby">
        <pre class="line-numbers"><code class="prism language-ruby" data-prism>def main(context)
  amountInEuros = context.req.query['amount']
  amountInDollars = amountInEuros * 1.13
  return context.res.send(amountInDollars)
end</code></pre>
      </div>
    </div>
  </li>
</ul>

<p>Commit your changes and push them to your Git repository.</p>


<h3>Testing our Function</h3>

<p>
  Execute the function and visit the URL (like <code>ghrfu9ewji.functions.appwrite.app?amount=5</code>) to see the response.
</p>
<p>
  You should see the result of the conversion, like <code>5.65</code>.
</p>

<h4>Adding Dependencies</h4>

<ul class="phases clear" data-ui-phases>
  <li>
    <h3>Node.js</h3>
    <div>
      <p>Run the following bash command to create a <code>package.json</code> file. This file is used to manage your Node.js project's dependencies.</p>
      <div class="ide margin-top-small" data-lang="bash" data-lang-label="Bash">
        <pre class="line-numbers"><code class="prism language-bash" data-prism>npm init -y</code></pre>
      </div>
      <p>Install the <code>undici</code> library. This library includes a <code>fetch</code> function that you can use to make HTTP requests.</p>
      <div class="ide margin-top-small" data-lang="bash" data-lang-label="Bash">
        <pre class="line-numbers"><code class="prism language-bash" data-prism>npm install undici</code></pre>
      </div>
      <p>Finally, add <code>npm install</code> to your function's build commands in the Appwrite console.</p>
    </div>
  </li>
  <li>
    <h3>PHP</h3>
    <div>
      <p>You can use Composer to manage your PHP project's dependencies. Install it from <a href="https://getcomposer.org/download/" target="_blank">getcomposer.org/download</a>.</p>
      <p>Run the following bash command to create a <code>composer.json</code> file. This file is used to manage your PHP project's dependencies.</p>
      <div class="ide margin-top-small" data-lang="bash" data-lang-label="Bash">
        <pre class="line-numbers"><code class="prism language-bash" data-prism>composer init -y</code></pre>
      </div>
      <p>Install the <code>guzzlehttp/guzzle</code> library. This library includes a <code>get</code> function that you can use to make HTTP requests.</p>
      <div class="ide margin-top-small" data-lang="bash" data-lang-label="Bash">
        <pre class="line-numbers"><code class="prism language-bash" data-prism>composer require guzzlehttp/guzzle</code></pre>
      </div>
      <p>Finally, add <code>composer install</code> to your function's build commands in the Appwrite console.</p>
    </div>
  </li>
  <li>
    <h3>Python</h3>
    <div>
      <p>Run the following bash command to create a <code>requirements.txt</code> file. This file is used to manage your Python project's dependencies.</p>
      <div class="ide margin-top-small" data-lang="bash" data-lang-label="Bash">
        <pre class="line-numbers"><code class="prism language-bash" data-prism>touch requirements.txt</code></pre>
      </div>
      <p>Install the <code>requests</code> library. This library includes a <code>get</code> function that you can use to make HTTP requests.</p>
      <div class="ide margin-top-small" data-lang="bash" data-lang-label="Bash">
        <pre class="line-numbers"><code class="prism language-bash" data-prism>echo "requests" >> requirements.txt
pip install -r requirements.txt</code></pre>
      </div>
      <p>Finally, add <code>pip install -r requirements.txt</code> to your function's build commands in the Appwrite console.</p>
    </div>
  </li>
  <li>
    <h3>
      Dart
    </h3>
    <div>
      <p>
        Create a <code>pubspec.yaml</code> file with the following contents. This file is used to manage your Dart project's dependencies.
      </p>
      <div class="ide margin-top-small" data-lang="yaml" data-lang-label="YAML">
        <pre class="line-numbers"><code class="prism language-yaml" data-prism>name: appwrite_function
description: Appwrite Function
version: 1.0.0
environment:
  sdk: '>=2.12.0 &lt;3.0.0'</code></pre>
      </div>
      <p>
        Install the <code>http</code> library. This library includes a <code>get</code> function that you can use to make HTTP requests.
      </p>
      <div class="ide margin-top-small" data-lang="bash" data-lang-label="Bash">
        <pre class="line-numbers"><code class="prism language-bash" data-prism>
          pub install http
        </code></pre>
      </div>
      <p>
        Finally, add <code>pub get</code> to your function's build commands in the Appwrite console.
      </p>
    </div>
  </li>
  <li>
    <h3>
      Ruby
    </h3>
    <div>
      <p>
        Create a <code>Gemfile</code> file with the following contents. This file is used to manage your Ruby project's dependencies.
      </p>
      <div class="ide margin-top-small" data-lang="ruby" data-lang-label="Ruby">
        <pre class="line-numbers"><code class="prism language-ruby" data-prism>source 'https://rubygems.org'
        </code></pre>
      </div>
      <p>
        Install the <code>httparty</code> library. This library includes a <code>get</code> function that you can use to make HTTP requests.
      </p>
      <div class="ide margin-top-small" data-lang="bash" data-lang-label="Bash">
        <pre class="line-numbers"><code class="prism language-bash" data-prism>echo "gem 'httparty'" >> Gemfile
bundle install</code></pre>
      </div>
      <p>
        Finally, add <code>bundle install</code> to your function's build commands in the Appwrite console.
      </p>
    </div>
  </li>
</ul>

<h3>Using Dependencies</h3>

<ul class="phases clear" data-ui-phases>
  <li>
    <h3>Node.js</h3>
    <div>
      <p>Use <code>fetch</code> from <code>undici</code> to get the current conversion rate. This API call will return the current conversion rate between Euros and Dollars.</p>
      <div class="ide margin-top-small" data-lang="javascript" data-lang-label="JavaScript">
        <pre class="line-numbers"><code class="prism language-js" data-prism>import { fetch } from 'undici';

export default async function ({ req, res }) {
  const amountInEuros = Number(req.query.amount);
  const response = await fetch('https://api.exchangerate.host/latest?base=EUR&symbols=USD');
  const data = await response.json();
  const amountInDollars = amountInEuros * data.rates.USD;
  return res.send(amountInDollars.toString());
};</code></pre>
      </div>
    </div>
  </li>
  <li>
    <h3>PHP</h3>
    <div>
      <p>
      <div class="ide margin-top-small" data-lang="php" data-lang-label="PHP">
        <pre class="line-numbers"><code class="prism language-php" data-prism>&lt;?php

require(__DIR__ . '/../vendor/autoload.php');

use GuzzleHttp\Client;

return function (&#36;context) {
  &#36;amountInEuros = &#36;context->getRequest()->getQuery('amount');
  &#36;client = new Client();
  &#36;response = &#36;client->get('https://api.exchangerate.host/latest?base=EUR&amp;symbols=USD');
  &#36;data = json_decode(&#36;response->getBody(), true);
  &#36;amountInDollars = &#36;amountInEuros * &#36;data['rates']['USD'];
  return &#36;context->res->send(strval(&#36;amountInDollars));
};</code></pre>
      </div>
    </div>
  </li>
  <li>
    <h3>Python</h3>
    <div>
      <p>Use <code>get</code> from <code>requests</code> to get the current conversion rate. This API call will return the current conversion rate between Euros and Dollars.</p>
      <div class="ide margin-top-small" data-lang="python" data-lang-label="Python">
        <pre class="line-numbers"><code class="prism language-python" data-prism>import requests

def main(context):
  amount_in_euros = float(context.req.query['amount'])
  response = requests.get('https://api.exchangerate.host/latest?base=EUR&symbols=USD')
  data = response.json()
  amount_in_dollars = amount_in_euros * data['rates']['USD']
  return context.res.send(str(amount_in_dollars))</code></pre>
      </div>
    </div>
  </li>
  <li>
    <h3>Dart</h3>
    <div>
      <p>Use <code>get</code> from <code>http</code> to get the current conversion rate. This API call will return the current conversion rate between Euros and Dollars.</p>
      <div class="ide margin-top-small" data-lang="dart" data-lang-label="Dart">
        <pre class="line-numbers"><code class="prism language-dart" data-prism>import 'dart:async';
import 'package:http/http.dart' as http;

Future&lt;dynamic> main(final context) async {
  final amountInEuros = double.parse(context.req.query['amount'])
  final response = await http.get(Uri.parse('https://api.exchangerate.host/latest?base=EUR&symbols=USD'));
  final data = json.decode(response.body);
  final amountInDollars = amountInEuros * data['rates']['USD'];
  return context.res.send(amountInDollars.toString());
}</code></pre>
      </div>
    </div>
  </li>
  <li>
    <h3>Ruby</h3>
    <div>
      <p>Use <code>get</code> from <code>httparty</code> to get the current conversion rate. This API call will return the current conversion rate between Euros and Dollars.</p>
      <div class="ide margin-top-small" data-lang="ruby" data-lang-label="Ruby">
        <pre class="line-numbers"><code class="prism language-ruby" data-prism>require 'httparty'

def main(context)
  amount_in_euros = context.req.query['amount'].to_f
  response = HTTParty.get('https://api.exchangerate.host/latest?base=EUR&symbols=USD')
  data = JSON.parse(response.body)
  amount_in_dollars = amount_in_euros * data['rates']['USD']
  return context.res.send(amount_in_dollars.to_s)
end</code></pre>
      </div>
    </div>
  </li>
</ul>

<p>After your function has updated, you can test it by visiting the URL and providing different amounts to convert in the query string. The conversion rate should now be more precise because we're using the current conversion rate.</p>

<h3>Adding Multiple Routes</h3>

<p>Let's add support multiple paths like <code>/eur</code> and <code>/inr</code>. Each path will convert from that currency to dollars.</p>

<ul class="phases clear" data-ui-phases>
  <li>
    <h3>Node.js</h3>
    <div>
      <p>
      <div class="ide margin-top-small" data-lang="javascript" data-lang-label="JavaScript">
        <pre class="line-numbers"><code class="prism language-js" data-prism>import { fetch } from 'undici';

export default async function ({ req, res }) {
  if (req.path === '/eur') {
    const amountInEuros = Number(req.query.amount);
    const response = await fetch('https://api.exchangerate.host/latest?base=EUR&symbols=USD');
    const data = await response.json();
    const amountInDollars = amountInEuros * data.rates.USD;
    return res.send(amountInDollars.toString());
  }

  if (req.path === '/inr') {
    const amountInRupees = Number(req.query.amount);
    const response = await fetch('https://api.exchangerate.host/latest?base=INR&symbols=USD');
    const data = await response.json();
    const amountInDollars = amountInRupees * data.rates.USD;
    return res.send(amountInDollars.toString());
  }

  return res.send('Invalid path');
};</code></pre>
      </div>
    </div>
  </li>
  <li>
    <h3>Python</h3>
    <div>
      <p>
      <div class="ide margin-top-small" data-lang="python" data-lang-label="Python">
        <pre class="line-numbers"><code class="prism language-python" data-prism>import requests

def main(context):
  if context.req.path == '/eur':
    amount_in_euros = float(context.req.query['amount'])
    response = requests.get('https://api.exchangerate.host/latest?base=EUR&symbols=USD')
    data = response.json()
    amount_in_dollars = amount_in_euros * data['rates']['USD']
    return context.res.send(str(amount_in_dollars))

  if context.req.path == '/inr':
    amount_in_rupees = float(context.req.query['amount'])
    response = requests.get('https://api.exchangerate.host/latest?base=INR&symbols=USD')
    data = response.json()
    amount_in_dollars = amount_in_rupees * data['rates']['USD']
    return context.res.send(str(amount_in_dollars))

  return 'Invalid path'</code></pre>
      </div>
    </div>
  </li>
  <li>
    <h3>Dart</h3>
    <div>
      <p>
      <div class="ide margin-top-small" data-lang="dart" data-lang-label="Dart">
        <pre class="line-numbers"><code class="prism language-dart" data-prism>import 'dart:async';
import 'package:http/http.dart' as http;

Future&lt;dynamic> main(final context) async {
  if (context.req.path == '/eur') {
    final amountInEuros = double.parse(context.req.query['amount'])
    final response = await http.get(Uri.parse('https://api.exchangerate.host/latest?base=EUR&symbols=USD'));
    final data = json.decode(response.body);
    final amountInDollars = amountInEuros * data['rates']['USD'];
    return context.res.send(amountInDollars.toString());
  }

  if (context.req.path == '/inr') {
    final amountInRupees = double.parse(context.req.query['amount'])
    final response = await http.get(Uri.parse('https://api.exchangerate.host/latest?base=INR&symbols=USD'));
    final data = json.decode(response.body);
    final amountInDollars = amountInRupees * data['rates']['USD'];
    return context.res.send(amountInDollars.toString());
  }

  return 'Invalid path';
}</code></pre>
      </div>
    </div>
  </li>
  <li>
    <h3>Ruby</h3>
    <div>
      <p>
      <div class="ide margin-top-small" data-lang="ruby" data-lang-label="Ruby">
        <pre class="line-numbers"><code class="prism language-ruby" data-prism>require 'httparty'

def main(context)
  if context.req.path == '/eur'
    amount_in_euros = context.req.query['amount'].to_f
    response = HTTParty.get('https://api.exchangerate.host/latest?base=EUR&symbols=USD')
    data = JSON.parse(response.body)
    amount_in_dollars = amount_in_euros * data['rates']['USD']
    return context.res.send(amount_in_dollars.to_s)
  end

  if context.req.path == '/inr'
    amount_in_rupees = context.req.query['amount'].to_f
    response = HTTParty.get('https://api.exchangerate.host/latest?base=INR&symbols=USD')
    data = JSON.parse(response.body)
    amount_in_dollars = amount_in_rupees * data['rates']['USD']
    return context.res.send(amount_in_dollars.to_s)
  end

  return 'Invalid path'
end</code></pre>
      </div>
    </div>
  </li>

</ul>

<p>After your function has updated, you can try out the new paths. For example, <code>ghrfu9ewji.functions.appwrite.app/eur?amount=5</code> should convert Euros to Dollars, while <code>ghrfu9ewji.functions.appwrite.app/inr?amount=100</code> should convert Indian Rupees to Dollars.</p>
<p>Congratulations! You've built a currency conversion API using Appwrite functions!</p>

<h2>Voting System Using Appwrite</h2>

<h3>Getting Started</h3>

<p>
  In this recipe, you will build a simple voting system that allows users to vote on various topics. Appwrite functions and the server SDK will be used to enforce voting rules and prevent multiple votes from the same user for a single topic.
</p>

<h3>Setting Up</h3>

<ul class="phases clear" data-ui-phases>
  <li>
    <h3>Appwrite Project</h3>
    <div>
      <p>1. Create a new Appwrite project.</p>
      <p>2. Add your development domain to your Appwrite project's trusted domains.</p>
    </div>
  </li>
  <li>
    <h3>Create Collections</h3>
    <div>
      <p>Create two collections named "topics" and "votes."</p>
      <p>For "topics" collection, have fields: title and description.</p>
      <p>For "votes" collection, have fields: topicId, userId, and vote.</p>
    </div>
  </li>
</ul>

<h3>Building the Voting Function</h3>

<ul class="phases clear" data-ui-phases>
  <li>
    <h3>Node.js</h3>
    <div>
      <p>Create a new located at <code>functions/vote/src/main.js</code>.</p>
      <div class="ide margin-top-small" data-lang="javascript" data-lang-label="JavaScript">
        <pre class="line-numbers"><code class="prism language-js" data-prism>import { Client, Databases, Query } from 'node-appwrite';

export default async function ({ req, res }) {
  const vote = {
    userId: req.query.userId,
    topicId: req.query.topicId,
    vote: req.query.vote
  };

  if (vote.vote !== 'yes' && vote.vote !== 'no') {
    return res.json({ ok: false, message: 'You must vote yes or no.' });
  }

  const client = new Client();
  client
    .setEndpoint('https://cloud.appwrite.io/v1')
    .setProject(process.env.APPWRITE_FUNCTION_PROJECT_ID)
    .setKey(process.env.APPWRITE_API_KEY);

  const database = new Database(client);
  
  const existingVotes = await database.listDocuments('[VOTES_COLLECTION_ID]', [
    Query.equals('userId', vote.userId),
    Query.equals('topicId', vote.topicId)
  ]);

  if (existingVotes.total > 0) {
    return res.json({ message: 'You have already voted on this topic.' });
  }

  const voteDocument = await database.createDocument('[VOTES_COLLECTION_ID]', {
    userId,
    topicId,
    vote,
  });

  return res.json({ ok: true, message: 'Vote cast.', vote: voteDocument });
}</code></pre>
    </div>
    </div>
  </li>
  <li>
    <h3>Python</h3>
    <div>
      <p>
      <div class="ide margin-top-small" data-lang="python" data-lang-label="Python">
        <pre class="line-numbers"><code class="prism language-python" data-prism>from appwrite.client import Client
from appwrite.services.databases import Databases
from appwrite.query import Query
import os

def main(context):
    vote = {
        'userId': context.req.query['userId'],
        'topicId': context.req.query['topicId'],
        'vote': context.req.query['vote']
    }

    if vote['vote'] != 'yes' and vote['vote'] != 'no':
        return context.res.json({'ok': False, 'message': 'You must vote yes or no.'})

    client = Client()
    client.set_endpoint('https://cloud.appwrite.io/v1')
    client.set_project(os.environ['APPWRITE_FUNCTION_PROJECT_ID'])
    client.set_key(os.environ['APPWRITE_API_KEY'])

    database = Databases(client)
    
    existing_votes = database.list_documents('[VOTES_COLLECTION_ID]', [
        Query.equals('userId', vote['userId']),
        Query.equals('topicId', vote['topicId'])
    ])

    if existing_votes['total'] > 0:
        return context.res.json({
          'ok': False, 
          'message': 'You have already voted on this topic.'
        })

    vote_document = database.create_document('[VOTES_COLLECTION_ID]', {
        'userId': vote['userId'],
        'topicId': vote['topicId'],
        'vote': vote['vote'],
    })

    return context.res.json({'ok': True, 'message': 'Vote cast.', 'vote': vote_document})</code></pre>
      </div>
    </div>
  </li>
  <li>
    <h3>PHP</h3>
    <div>
      <p>
      <div class="ide margin-top-small" data-lang="php" data-lang-label="PHP">
        <pre class="line-numbers"><code class="prism language-php" data-prism>&lt;?php

require(__DIR__ . '/../vendor/autoload.php');

use Appwrite\Client;
use Appwrite\Exception;
use Appwrite\Services\Database;
use Appwrite\Query;

return function ($context) {
    $vote = [
        'userId' => $context->req->query['userId'],
        'topicId' => $context->req->query['topicId'],
        'vote' => $context->req->query['vote']
    ];

    if ($vote['vote'] !== 'yes' && $vote['vote'] !== 'no') {
        return $context->res->json(['ok' => false, 'message' => 'You must vote yes or no.']);
    }

    $client = new Client();
    $client
        ->setEndpoint('https://cloud.appwrite.io/v1')
        ->setProject(getenv('APPWRITE_FUNCTION_PROJECT_ID'))
        ->setKey(getenv('APPWRITE_API_KEY'));

    $database = new Database($client);

    $existingVotes = $database->listDocuments('[VOTES_COLLECTION_ID]', [
        Query->equal('userId', $vote['userId']),
        Query->equal('topicId', $vote['topicId'])
    ]);

    if ($existingVotes['total'] > 0) {
        return $context->res->json([
          'ok' => false, 
          'message' => 'You have already voted on this topic.'
        ]);
    }

    $voteDocument = $database->createDocument('[VOTES_COLLECTION_ID]', [
        'userId' => $vote['userId'],
        'topicId' => $vote['topicId'],
        'vote' => $vote['vote'],
    ]);

    return $context->res->json([
      'ok' => true, 
      'message' => 'Vote cast.', 
      'vote' => $voteDocument
    ]);
};</code></pre>
      </div>
    </div>
  </li>
  <li>
    <h3>Ruby</h3>
    <div>
      <p>
      <div class="ide margin-top-small" data-lang="ruby" data-lang-label="Ruby">
        <pre class="line-numbers"><code class="prism language-ruby" data-prism>require "appwrite"

def main(context)

    vote = {
        'userId' => context.req.query['userId'],
        'topicId' => context.req.query['topicId'],
        'vote' => context.req.query['vote']
    }

    if vote['vote'] != 'yes' and vote['vote'] != 'no'
        return context.res.json({'ok': false, 'message': 'You must vote yes or no.'})
    end

    client = Appwrite::Client.new()
    client
        .set_endpoint('https://cloud.appwrite.io/v1')
        .set_project(ENV['APPWRITE_FUNCTION_PROJECT_ID'])
        .set_key(ENV['APPWRITE_API_KEY'])

    database = Appwrite::Database.new(client)
    
    existing_votes = database.list_documents('[VOTES_COLLECTION_ID]', [
        Appwrite::Query.new('userId', '=', vote['userId']),
        Appwrite::Query.new('topicId', '=', vote['topicId'])
    ])

    if existing_votes['total'] > 0
        return context.res.json({
          'ok': false, 
          'message': 'You have already voted on this topic.'
        })
    end

    vote_document = database.create_document('[VOTES_COLLECTION_ID]', {
        'userId': vote['userId'],
        'topicId': vote['topicId'],
        'vote': vote['vote'],
    })

    return context.res.json({
      'ok': true, 
      'message': 'Vote cast.', 
      'vote': vote_document
    })
end</code></pre>
      </div>
    </div>
  </li>
  <li>
    <h3>Dart</h3>
    <div>
      <p>
      <div class="ide margin-top-small" data-lang="dart" data-lang-label="Dart">
        <pre class="line-numbers"><code class="prism language-dart" data-prism>import 'dart:async';
import 'package:dart_appwrite/dart_appwrite.dart';

Future<dynamic> main(final context) async {
    final vote = {
        'userId': context.req.query['userId'],
        'topicId': context.req.query['topicId'],
        'vote': context.req.query['vote']
    };

    if (vote['vote'] != 'yes' && vote['vote'] != 'no') {
        return context.res.json({'ok': false, 'message': 'You must vote yes or no.'});
    }

    final client = Client()
        .setEndpoint('https://cloud.appwrite.io/v1')
        .setProject(process.env.APPWRITE_FUNCTION_PROJECT_ID)
        .setKey(process.env.APPWRITE_API_KEY);

    final database = Database(client);

    final existingVotes = await database.listDocuments('[VOTES_COLLECTION_ID]', [
        Query.equals('userId', vote['userId']),
        Query.equals('topicId', vote['topicId'])
    ]);

    if (existingVotes['total'] > 0) {
        return context.res.json({
          'ok': false, 
          'message': 'You have already voted on this topic.'
        });
    }

    final voteDocument = await database.createDocument('[VOTES_COLLECTION_ID]', {
        'userId': vote['userId'],
        'topicId': vote['topicId'],
        'vote': vote['vote'],
    });

    return context.res.json({
      'ok': true, 
      'message': 'Vote cast.', 
      'vote': voteDocument
    });
}</code></pre>
      </div>
    </div>
  </li>
  <li>
    <h3>Python</h3>
    <div>
      <p>
      <div class="ide margin-top-small" data-lang="python" data-lang-label="Python">
        <pre class="line-numbers"><code class="prism language-python" data-prism>from appwrite.client import Client
from appwrite.services.databases import Databases
from appwrite.query import Query

import os

def main(context):
    vote = {
        'userId': context.req.query['userId'],
        'topicId': context.req.query['topicId'],
        'vote': context.req.query['vote']
    }

    if vote['vote'] != 'yes' and vote['vote'] != 'no':
        return context.res.json({'ok': False, 'message': 'You must vote yes or no.'})

    client = Client()
    client.set_endpoint('https://cloud.appwrite.io/v1')
    client.set_project(os.environ['APPWRITE_FUNCTION_PROJECT_ID'])
    client.set_key(os.environ['APPWRITE_API_KEY'])

    database = Databases(client)

    existing_votes = database.list_documents('[VOTES_COLLECTION_ID]', [
        Query.equal('userId', vote['userId']),
        Query.equal('topicId', vote['topicId'])
    ])
    
    if existing_votes['total'] > 0:
        return context.res.json({
          'ok': False, 
          'message': 'You have already voted on this topic.'
        })

    vote_document = database.create_document('[VOTES_COLLECTION_ID]', vote)

    return context.res.json({
      'ok': True, 
      'message': 'Vote cast.', 
      'vote': vote_document
    })</code></pre>
      </div>
    </div>
  </li>
</ul>

<p>In the Appwrite console, create a function and use the file you created as the entry point.</p>

<h3>Testing the Function</h3>

<p>
  Execute the function and visit the URL, passing the required parameters <code>[YOUR_FUNCTION_URL]?userId=[USER_ID]&amp;topicId=[TOPIC_ID];&amp;vote=yes</code> to cast a vote. You should see a response confirming the vote. Trying to vote again with the same user ID and topic ID should result in a message indicating that the user has already voted on this topic.
</p>

<h3>Conclusion</h3>

<p>
  To further improve this function, try adding the following checks:
  <ul>
    <li>Check that the user ID and topic ID exist.</li>
    <li>Replace the user ID query parameter with the <code>x-appwrite-user-id</code> header, so votes may only be cast by logged in users.</li>
    <li>Convert the function to POST requests with a JSON body to cast votes, so that the vote data is not visible in the URL.</li>
  </ul>
</p>

<p>
  Congratulations! You've built a voting system that leverages Appwrite functions and the Appwrite server SDK to enforce business logic and ensure that users can only vote once per topic.
</p>


[TODO: @luke -> Example with JWT, show both client and server code]

<!-- Here's more ideas -->

<!-- 
  How to handle different methods (POST, GET, PUT,DELETE)
  How to cache response (cache headers, json)
  How to file response (send img file, also cache it)
  How to handle HTML form submittion
  How to do basic auth (there is some header for it)
  How to recieve data in body
  How to redirect
  How to log
  How to do Bearer Auth
  How to access event data
  How to access env vars 
-->